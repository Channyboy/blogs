---
layout: post
title: "New Simple Timer metric with MicroProfile Metrics 2.3"
categories: blog
author_picture: https://avatars1.githubusercontent.com/Channyboy
author_github: https://github.com/Channyboy
seo-title: New Simple Timer metric with MicroProfile Metrics 2.3 - OpenLiberty.io
seo-description: New Simple Timer metric with MicroProfile Metrics 2.3. Its' introduction also brings with it the new runtime provided REST metrics.
blog_description: "MicroProfile Metrics 2.3 introduces a new time based metric called the Simple Timer. It is a light-weight alternative to the existing Timer metric. Its' debut also brings with it the new MicroProfile runtime provided REST metrics."
---
= New Simple Timer metric with MicroProfile Metrics 2.3
David Chan <https://github.com/Channyboy>

The release of https://github.com/eclipse/microprofile-metrics/tree/960eb82c00e8fb6753bf1af74ae11bc5951dcaa7[MicroProfile Metrics 2.3] brings the debut of the new simple timer metric. The simple timer is a light-weight alternative to the existing timer metric and will satisfy most existing use-cases for timers. The practicality of using the simple timer is apparent if the metric data is intended to be fed into the [Prometheus monitoring tool](#viewing-data-with-prometheus-and-grafana) <<Viewing-data-with-Prometheus-and-Grafana,Prometheus monitoring tool>>. This is due to the effectiveness of using PromQL https://prometheus.io/docs/prometheus/latest/querying/functions/[functions] to formulate additional values from raw metric data.


Like the timer metric, the simple timer works by tracking timing durations and the frequency of invocations where the metric is instrumented. Unlike the timer metric, however,  and true to its _simple_ nature, the simple timer only reports those 2 values. The timer metric on the other hand aggregates the recorded data to calculate throughput and duration statistics resulting in 14 different values. For accurate reporting of these values the timer metric keeps track of the most recent 1000 data points for use in its calculations. Here we can highlight the benefits of using the simple timer with Prometheus.  Four of the 14 values provided by the timer are to represent the mean, 1-min, 5-min and 15-minute rates. These calculations can be easily deferred to the Prometheus client-side with the use of the PromQL https://prometheus.io/docs/prometheus/latest/querying/functions/#rate)[rate()] function and https://prometheus.io/docs/prometheus/latest/querying/basics/#range-vector-selectors[range vector selectors]. Lastly, the simple timer brings with it the ability to report the total elapsed timing duration. This is something that the timer currently lacks. If all you wanted to do was just _simply_ time something then the simple timer should be your metric of choice. See the below table for a comparison of the values provided by both metrics.

[%header,adoc]
|===
|  Timer metric values |  Simple timer metric values
a|
* Count    
* Mean rate
* 1-min rate
* 5-min rate
* 15-min rate
* Minimum
* Maximum*
* Mean*
* Standard deviation*
* 50th percentile*
* 75th percentile**
* 98th percentile*
* 99th percentile*
* 999th percentile*

*of recorded time duration
a|* Count
  * Elapsed Time
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
  {empty} +
|===

{empty} +

[%header]
|===
|The list of available metric types as of MicroProfile Metrics 2.3
|Counter
|Gauge
|Concurrent Gauge
|Meter
|Histogram
|Timer
|**Simple Timer**
|===
  
== Simple Timer usage


Before we begin, if you’re using an Open Liberty server, remember to configure it with the `mpMetrics-2.3` feature in your `server.xml`.


```
<server>
    <featureManager>
        <feature>mpMetrics-2.3</feature>
        …
    </featureManager>
     …
</server>
```


Like all metrics available in Microprofile Metrics the simple timer can be instrumented into your application with annotations or instrumented and manipulated programmatically. This blog will only cover usage with annotations. You can consult the https://github.com/eclipse/microprofile-metrics/blob/960eb82c00e8fb6753bf1af74ae11bc5951dcaa7/api/src/main/java/org/eclipse/microprofile/metrics/SimpleTimer.java[Java API] documentation on how to use the simple timer programmatically.
 
The annotation for the simple timer is `@SimplyTimed`. The following example shows how to use the simple timer’s annotations (@SimplyTimed) with the available annotation parameters:


```
@SimplyTimed(name=“sampleSimplyTimed” , displayName=”mySampleSImpleTimer”, description=”A simple timer description”, absolute=true, reusable=true,  tags= {"tag1=value1", "tag2=value2"})
public void simplyTimeSomething() { 
   Thread.sleep(2000);
}
```
You can view the annotation's API https://github.com/eclipse/microprofile-metrics/blob/960eb82c00e8fb6753bf1af74ae11bc5951dcaa7/api/src/main/java/org/eclipse/microprofile/metrics/annotation/SimplyTimed.java[here] and an overview of the metric's attributes, which the annotation parameters are used to define, in the specification https://github.com/eclipse/microprofile-metrics/blob/960eb82c00e8fb6753bf1af74ae11bc5951dcaa7/spec/src/main/asciidoc/architecture.adoc#metadata[here].


You can then view the data at the `/metrics` REST endpoint. By default, the metric data is formatted in https://prometheus.io/docs/concepts/data_model/[OpenMetrics/Prometheus format].


`GET` request to `/metrics` with `text/plain` for OpenMetrics/Prometheus formatted data


```
# TYPE application_sampleSimplyTimed_total counter
# HELP application_sampleSimplyTimed_total A simple timer description
application_sampleSimplyTimed_total{colour="blue",shape="square"} 1
# TYPE application_sampleSimplyTimed_elapsedTime_seconds gauge 
application_sampleSimplyTimed_elapsedTime_seconds{colour="blue",shape="square"} 2.620000000
```
 
== REST Metrics
 
With the new simple timer metric the specification for MicroProfile Metrics 2.3 also states that runtimes can track and monitor the usage of REST/JAX-RS method resources and report it with a simple timer metric. 


The metrics created by the runtime have the `REST.request` metric name and will be labeled with their fully qualified class name and method signature.


The following  example is from the MicroProfile Metrics specification regarding the `REST.request` https://github.com/eclipse/microprofile-metrics/blob/960eb82c00e8fb6753bf1af74ae11bc5951dcaa7/spec/src/main/asciidoc/required-metrics.adoc#optional-rest[metric].


For example given the following RESTful resource:
```
package org.eclipse.microprofile.metrics.demo;


@ApplicationScoped
public class RestDemo {


  @POST
  public void postMethod(String... s, Object o){
      ...
  }
}
```


The OpenMetrics formatted REST metrics would be:
```
# TYPE base_REST_request_total counter
base_REST_request_total{class="org.eclipse.microprofile.metrics.demo.RestDemo",method="postMethod_java.lang.String[]_java.lang.Object"} 1
# TYPE base_REST_request_elapsedTime_seconds gauge
base_REST_request_elapsedTime_seconds{class="org.eclipse.microprofile.metrics.demo.RestDemo",method="postMethod_java.lang.String[]_java.lang.Object"} 1.000
```


== Viewing data with Prometheus and Grafana
 
You'll also need a way to record and view metrics from all of your servers. A common approach is to use https://prometheus.io/[Prometheus] and https://grafana.com/[Grafana]. Prometheus is an open-sourced monitoring tool used for retrieving and indexing metric data that are exported with the Prometheus/OpenMetrics format. Grafana, also an open-sourced monitoring tool, can utilize that data and display it through graphs and visualizations.


We will use the REST section of the _mpMetrics 2.x_ Grafana dashboard, that is provided by the Open Liberty team, to illustrate a few possible visualizations that can be created from simple timer metric data. 


But first, an explanation of the underlying runtime and application environment:

* There are two Open Liberty servers running the same application on two separate Docker containers
** One OpenLiberty instance is named `OpenLiberty`
** **One OpenLiberty instance is named `OpenLiberty2`
    
* There are two `GET` REST endpoints in the application

* One of the GET REST method resources is named `getMethod` which accepts no parameters
** One of the GET REST method resources is named `getMethodParam` which accepts one parameter of a `javax.ws.core.HTTPHeader` object (unfortunately the full value of the method signature is cut off in the Grafana legend)


REST Graph/Visualizations:

image::/img/blog/blog_mpmetrics_grafana_REST_dashboard.png[align="center"]

Note: The PromQL queries below originally used the following label scope `{instance=~`[[instance]]`}` and `[[dur]]` variable. These values are defined by the dashboard.  The default is `all` instances and a duration of `10m` (i.e 10 minutes). For ease of readability, the `{instance=~`[[instance]]`}`  is omitted and the `[[dur]]` has been substituted as [10m].


***


=== REST Request Count Over Last [10m]


PromQL Query: `increase(base_REST_request_total[10m])`


This graph visualization, as the title suggests, queries and calculates the request count for each REST method resource for the last 10 minutes by using the REST simple timer's `count` value. To effectively show this we use the https://prometheus.io/docs/prometheus/latest/querying/functions/#increase[increase()]( function with the range vector selector of 10 minutes (i.e 10m). 


***


=== Request Count by REST Resource Over Last [10m]


PromQL Query: `sum(increase(base_REST_request_total[10m])) by (class, method)`


This graph visualization is similar to the one above. Once again we are calculating the request count for the last 10 minutes.  However, now we are aggregating the metric data of matching metrics (i.e  matching REST method resources) across multiple applications or container instances and combining them into one. This aggregation is accomplished by calling the `sum()` https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators[aggregation operator] to add up the metric values acquired from using the `by` clause. Our use of the by clause as `by (class, method)` limits the metric dimension to only the `class` and `method` label  allowing us to aggregate across the `instance`label dimension (i.e across containers). 


=== Average Response Time per REST Request Over Last [10m] 


PromQL Query: `rate(base_REST_request_elapsedTime_seconds[10m]) / rate(base_REST_request_total{[10m])`


This graph visualization, as the title suggests, queries and calculates the average response time for each REST method resource for the last 10 minutes by using the simple timer's `elapsedTime` and `count`metric values. The use of `rate()` here is needed for use with the range vector selector.


***


=== Average Response Time per Request Over Last [10m] 


PromQL Query: `avg(rate(base_REST_request_elapsedTime_seconds[10m]) / rate(base_REST_request_total[10m])) by (class, method)`


This graph visualization is similar to the one above. Once again we are calculating the average response time of REST endpoints for the last 10 minutes. However, now we are aggregating the metric data of matching metrics (i.e  matching REST method resources) across multiple applications or container instances and combining them into one. This aggregation is accomplished by calling the `avg()` https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators[aggregation operator] to calculate the average over the metric values acquired from using the `by` clause. Our use of the by clause as `by (class, method)` limits the metric dimension to only the `class` and `method` label  allowing us to aggregate across the `instance` label  dimension (i.e across containers).

***

=== Slowest REST Resources Over Last [10m] by Average Response Time
PromQL Query: `avg(rate(base_REST_request_elapsedTime_seconds[10m]) / rate(base_REST_request_total{instance=[10m])) by (class, method) > 0`


This table visualization is simply a table form of the above _Average Response Time per Request Over Last [10m]_ visualization. The table shows the _slowest_ by sorting the table from highest _Average Reponse Time_ to lowest.


***


By just using the two values provided by simple timer and combining it with PromQL functions, we are able to create visualizations useful for use in monitoring REST method resources from a single instance to a highly scaled operation environment. Similar visualizations can be created for simple timer metrics instrumented in applications. Additional visualizations can be created with further use of the PromQL functions to suit the particular needs of different end-users. The mpMetrics-2.x Grafana dashboard hosts many more visualizations that are created from the metric data exported by the Open Liberty run-time (i.e the base and vendor metrics) and is downloadable https://grafana.com/grafana/dashboards/11706[here]. If running on https://www.openshift.com/products/container-platform[Open Shift Container Platforms] see this https://github.com/OpenLiberty/open-liberty-operator/tree/master/deploy/dashboards/metrics[link] for Grafana dashboards for that environment.


== Summary 


The new simple timer metric brings a simple yet powerful new metric into the world of MicroProfile Metrics. Its addition into the specification also brought with it the inclusion of REST endpoint monitoring for the MicroProfile Metrics runtime.  Combined with using PromQL functions in Grafana, the simple timer proves itself to be highly versatile for building graphs and visualizations.  As compared to the existing timer metric, the simple timer is much lighter-weight while still providing enough information for most use cases.

---
layout: post
title: "Asynchronous programming made resilient with MicroProfile Fault Tolerance"
categories: blog
author_picture: https://avatars2.githubusercontent.com/u/55994281?s=460&u=e02b856ba160c3a4275f760606f679811c90a1af&v=4
author_github: https://github.com/Joseph-Cass
seo-title: Using MicroProfile Fault Tolerance @Asynchronous Open Liberty - OpenLiberty.io
seo-description: MicroProfile Fault Tolerance @Asynchronous allows you to add additional functionality to @Timeout and @Bulkhead annotations and allows you to use the other Fault Tolerance annotations with other asynchronous APIs.
blog_description: "MicroProfile Fault Tolerance @Asynchronous allows you to add additional functionality to @Timeout and @Bulkhead annotations and allows you to use the other Fault Tolerance annotations with other asynchronous APIs"
additional_authors: 
 - name: Andrew Rouse
   github: https://github.com/Azquelt
   image: https://avatars3.githubusercontent.com/u/2011102?s=460&u=4754ac398d208d72a7aff0bdeab828562a192d53&v=4
---
= Asynchronous programming made resilient with MicroProfile Fault Tolerance
Joseph Cass <https://github.com/Joseph-Cass>

https://www.oracle.com/technetwork/java/javase/overview/java8-2100321.html[Java 8] is long-term support and https://www.jetbrains.com/lp/devecosystem-2019/java/[the most commonly used Java version]. It has many awesome features; one of which is https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html[CompletionStage], which allows you to make your code asynchronous. Great stuff! However, you might have the following questions:

[.text-center]
*_"How can I make my asynchronous methods resilient to faults? What if an asynchronous method unexpectedly returns an exception? What happens then?"_*

=== MicroProfile Fault Tolerance

Luckily https://github.com/eclipse/microprofile-fault-tolerance[MicroProfile Fault Tolerance] comes to rescue. In this blog post we will go through how to make your asynchronous program resilient.

There are many different annotations which MicroProfile Fault Tolerance provides for helping you deal with failure: https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1/apidocs/org/eclipse/microprofile/faulttolerance/Retry.html[@Retry], https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1/apidocs/org/eclipse/microprofile/faulttolerance/Timeout.html[@Timeout], https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1/apidocs/org/eclipse/microprofile/faulttolerance/CircuitBreaker.html[@CircuitBreaker], https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1/apidocs/org/eclipse/microprofile/faulttolerance/Bulkhead.html[@Bulkhead] and https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1/apidocs/org/eclipse/microprofile/faulttolerance/Fallback.html[@Fallback].

But there's one in particular we're going to talk about which is slightly different: https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1/apidocs/org/eclipse/microprofile/faulttolerance/Asynchronous.html[@Asynchronous].

Asynchronous isn't a strategy for dealing with failure, so why is it in MicroProfile Fault Tolerance? Well, it allows us to add some additional functionality to the `@Timeout` and `@Bulkhead` annotations, and it allows us to use the other Fault Tolerance annotations with other asynchronous APIs.

Before we talk about how `@Asynchronous` enhances other annotations, let's talk about what it does on its own.

== What does `@Asynchronous` do?
The `@Asynchronous` annotation makes your method run asynchronously, meaning that rather than running when you call it, it will run some time later, usually on another thread.

One of the ways we can use this is to run several things in parallel. To do this, we add the `@Asynchronous` annotation to the method, and we change the method to return either a https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html[CompletionStage] (preferable) or https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html[Future]. In our method body, we can use `CompletableFuture.completedFuture()` to make our result compatible with the new return type.

[source,java]
----
@Asynchronous
public CompletionStage<String> serviceA() { 

	return CompletableFuture.completedFuture("serviceA");

}
----

=== `@Asynchronous` method execution
So what does this do when we call the method?

Well, usually when you call a method, you call it, and then it returns a result. However, when we use the `@Asynchronous` annotation, Fault Tolerance gets in between. When you call the method, Fault Tolerance first schedules your method to run later on a different thread, then it returns you a `CompletionStage` or `Future`. This isn't the `CompletionStage` or `Future` that's returned from your method, because your method hasn't run yet, it's an object created entirely by Fault Tolerance. 

image::/img/blog/FT-basic-asynchronous-execution.png[Fault Tolerance asynchronous execution flow]

Sometime later, your method runs and returns a `CompletionStage` or `Future`. Now, Fault Tolerance will go and complete the `CompletionStage` or `Future` object which was returned to the caller earlier, with the value that was returned from your method.


== How you can use `@Asynchronous`
We’re going to go through 2 potential use-cases:

1. Using `@Asynchronous` annotation to do two things in parallel
2. Applying Fault Tolerance to an API which is already asynchronous

=== Let’s go parallel!
To run two methods in parallel, you can write methods which call two other services, annotate them both with the `@Asynchronous` annotation, then call them like this:

[source,java]
----
@Inject
private RequestScopedClass1 requestScopedBean1;

@Inject
private RequestScopedClass2 requestScopedBean2;

public CompletionStage<String> callServicesAsynchronously()  {

	CompletionStage<String> result1 = requestScopedBean1.serviceA(); // Where serviceA is annotated with @Asynchronous
	CompletionStage<String> result2 = requestScopedBean2.serviceB(); // Where serviceB is annotated with @Asynchronous	
    ...
}
----

First, serviceA is called, and then serviceB, then the program waits for results from both. This lets both services be called simultaneously, rather than sequentially. 

Any other Fault Tolerance annotations can also be used. For example, a Retry can be added to serviceA and a Timeout to serviceB. If serviceA needs several retries, then call to retrieve the result, such as `CompletionStage.thenAccept()` or  `Future.get()` won't return until all the retries are complete.

[source,java]
----
@RequestScoped
public class RequestScopedClass1 {
	
	@Retry
	@Asynchronous
	public CompletionStage<String> serviceA() { 

        doSomethingWhichMightFail()
		return CompletableFuture.completedFuture("serviceA");

	}
}

@RequestScoped
public class RequestScopedClass2 {
	
	@Timeout
	@Asynchronous
	public CompletionStage<String> serviceB() { 

        doSomethingWhichMightFail()
		return CompletableFuture.completedFuture("serviceB");

	}
}
----

=== Applying to An Already Asynchronous API (AAAAA)
(Disclaimer: not an official acronym…)

Another use is to apply Fault Tolerance to an API which is already asynchronous. We can do this with any API which does something Asynchronously and returns a `CompletionStage`.

In this example, we'll use the JAX-RS client API for calling remote REST services, introduced in JAX-RS 2.1. We can build up a request to fetch a String from a given URL with a GET request and the return type is a `CompletionStage` of String:

==== JAX-RS client API `CompletionStage` example:

[source,java]
----
private Client client = ClientBuilder.newClient();

public CompletionStage<String> clientDemo() {

    CompletionStage<String> response = client.target("http://example.com/resource")
                     .request(MediaType.TEXT_PLAIN)
                     .rx()
                     .get(String.class);

    return response;
	
}
----
==== Fetching the following resource:
[source,java]
----
@GET
@Path("/resource")
public CompletionStage<String> fetchExample() { 

	return CompletableFuture.completedFuture("responseText");

}
----

If we call the `clientDemo()` method, without any annotations, it works as we expect. We call it, receive a `CompletionStage<String>` (named `response` in the example), and then we can add an action to take when the `CompletionStage` completes.

[source,java]
----
response.thenAccept(System.out::println);
--> responseText
----

However, what happens if we want to use the `@Retry` annotation with our method? The answer is nothing. 

Even if the HTTP request fails, the request doesn't get retried. Why is this? Well, Fault Tolerance acts around method calls. If you annotate a method with `@Retry` and it throws an exception then it gets retried. However, when we do an HTTP request through this JAX-RS client API, if there's a problem it doesn't throw an exception. It can't throw an exception. It's going to do the request asynchronously, so when this method returns, it probably hasn't even made the request yet, let alone found out that it failed. If an exception does occur, it will be propagated  to the `CompletionStage` and can be handled there. But the result is, that this method will never throw an exception, even if the request fails and so the request will never be retried.

*@Asynchronous to the rescue!*

However, if we add the `@Asynchronous` annotation and the method returns a `CompletionStage`, then the Fault Tolerance logic gets applied when the `CompletionStage` completes, rather than when the method returns. 

[source,java]
----
@Asynchronous
@Retry
public CompletionStage<String> clientDemo() {
    ...
}
----

That means that when we call this method and it returns a `CompletionStage`, it's only when that `CompletionStage` completes that Fault Tolerance will look at the result and decide whether to retry. So, if the request fails, the `CompletionStage` completes with an exception, Fault Tolerance decides that a Retry is needed and it calls the method again. As before, Fault Tolerance has intercepted the method call, so the `CompletionStage` returned to the caller is a different `CompletionStage` so that the caller doesn't get the result until all the Retries have been completed.

So to recap, to use Fault Tolerance with an asynchronous API you must:

1. **Return a `CompletionStage` from your method** - You can't do this with a `Future`, it must be a `CompletionStage`.
2. **Use the `@Asynchronous` annotation** - When you do these two things, all the other Fault Tolerance logic is applied when the `CompletionStage` completes, rather than when the method returns.


== Interactions with other Fault Tolerance annotations
We've covered running things in parallel and applying Fault Tolerance to asynchronous APIs, now let's look at the way using the `@Asynchronous` annotations affects other Fault Tolerance annotations.

=== Timeout
When you use the `@Asynchronous` and `@Timeout` annotations together, the `CompletionStage` or `Future` returned to the caller can be completed as soon as the timeout expires, even if the method is still running. This is because the method is running on another thread, so even though that thread is still occupied, we can signal that the result is ready to another thread which might be waiting for it.

The thread running the method is still interrupted, so it can stop what it's working on and save resources, but if you need to apply a timeout to a long running operation which doesn't respond to being interrupted, you can use the `@Asynchronous` annotation. 

Note: Be aware that the operation may still run to completion, even though the timeout has expired and you've received the TimeoutException.


=== Bulkhead
When you use the `@Asynchronous` and `@Bulkhead` annotations together, Fault Tolerance provides the option to queue up executions if the maximum number of executions are already running. This is allowed because any calling code has been written with the knowledge that the method is asynchronous and won't return immediately. 

When you call the method, if there are less than the maximum concurrent executions running then your method is scheduled to run immediately, otherwise it's added to a queue. When one execution of the method finishes, if there are any on the queue then the first execution from the queue is started. If the queue itself is full, then the method fails with a `BulkheadException`.

Just like the number of concurrent executions, the size of the queue can also be configured using the `waitingTaskQueue` parameter on the `@Bulkhead` annotation.

== Asynchronous flow of execution
The last thing we're going to cover is how the flow of execution changes when using the `@Asynchronous` annotation compared to when it's not used. 

The following diagram demonstrates how Fault Tolerance is applied when a method annotated with `@Asynchronous` is executed and is accurate for mpFaultTolerance-2.0. The differences from synchronous execution are highlighted in dark green, and discussed below:

image::/img/blog/FT-asynchronous-execution-flow.png[Fault Tolerance asynchronous execution flow]

The first difference from synchronous flow of execution is that a `CompletionStage` or `Future` is returned before the method runs. When the method has actually returned, the result from the method is then propagated into the `CompletionStage` or `Future` so that the caller can get it. 

The next difference comes in the Bulkhead. As well as either accepting or rejecting the execution, the Bulkhead can also queue it to be run later. Next, if the method is accepted by the Bulkhead, it then is scheduled to be run on another thread, rather than run immediately. We then see the enhancement to Timeout. If the timeout expires, the method is interrupted, but we also skip forwards to this point and process the result as if the method had finished with a TimeoutException. 

The last difference is that if there's a fallback, it also runs asynchronously, so it's scheduled to run on another thread as well.

If a method returns a `CompletionStage` rather than a `Future`, then there's one more difference to synchronous flow of execution. If the method returns a value rather than throwing an exception, we wait until that `CompletionStage` completes before doing the rest of the Fault Tolerance logic. A few things to point out here: 

* The execution reserves a space on the Bulkhead here and doesn't release it until here, after the returned` `CompletionStage` completes. So, as far as the Bulkhead is concerned, it's still "executing" until the `CompletionStage` is complete. 
* The timeout starts before we check if there’s space on the Bulkhead, at which point it might be queued. If it is queued, the time it spends queuing still counts towards the timeout. 
* Similarly, the timeout isn't stopped until after the `CompletionStage` completes. 

In general, these are all behaviours we want. For example, if we're setting a timeout to get a response in a particular time, we're not bothered about whether the response took too long because there was a long queue at the Bulkhead, or because the task took too long, we still need a response within a particular time, but it's good to know what the differences are when you use the `@Asynchronous` annotation and return a `CompletionStage`.
